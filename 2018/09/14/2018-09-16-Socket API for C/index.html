<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>C 语言的 Socket 编程 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="C 语言下的 Socket 常用接口: 包括创建、绑定、监听、连接、读写等等。   socket123#include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;sys/socket.h&amp;gt;int socket(int family,int type,int protocol) 参数 family: 协议簇 AF_INET,AF_UNIX type:  SOCK_STRE">
<meta property="og:type" content="article">
<meta property="og:title" content="C 语言的 Socket 编程">
<meta property="og:url" content="http://1t4chi.com/2018/09/14/2018-09-16-Socket API for C/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="C 语言下的 Socket 常用接口: 包括创建、绑定、监听、连接、读写等等。   socket123#include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;sys/socket.h&amp;gt;int socket(int family,int type,int protocol) 参数 family: 协议簇 AF_INET,AF_UNIX type:  SOCK_STRE">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-03-12T16:30:29.218Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C 语言的 Socket 编程">
<meta name="twitter:description" content="C 语言下的 Socket 常用接口: 包括创建、绑定、监听、连接、读写等等。   socket123#include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;sys/socket.h&amp;gt;int socket(int family,int type,int protocol) 参数 family: 协议簇 AF_INET,AF_UNIX type:  SOCK_STRE">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://1t4chi.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2018-09-16-Socket API for C" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/14/2018-09-16-Socket API for C/" class="article-date">
  <time datetime="2018-09-14T01:25:53.000Z" itemprop="datePublished">2018-09-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Socket/">Socket</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      C 语言的 Socket 编程
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>C 语言下的 Socket 常用接口: 包括创建、绑定、监听、连接、读写等等。</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> family,<span class="keyword">int</span> type,<span class="keyword">int</span> protocol)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li>family: 协议簇 AF_INET,AF_UNIX</li>
<li>type: <ul>
<li>SOCK_STREAM:TCP</li>
<li>SOCK_DGRAM:UDP</li>
<li>SOCK_RAW:IP</li>
</ul>
</li>
<li>protocol: 默认为0</li>
</ul>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>大于0-socket描述符，-1-失败 </p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sockfd=socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(sockfd==<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Cannot create socket\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>并不是上面的type和protocol可以随意组合的<br>如SOCK_STREAM不可以跟IPPROTO_UDP组合<br>当protocol为0时，会自动选择type类型对应的默认协议</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr * myaddr,<span class="keyword">int</span> addrlen)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><p>sockfd socket 描述符<br>myaddr 一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，<br>addrlen 地址长度</p>
<h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>大于0<br>-1</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(bind(sockfd,(struct sockaddr*)&amp;srvaddr,sizrof(truct sockaddr))==<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Bind error\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><p><strong>不会产生阻塞</strong><br>客户端与服务器都可以绑定 socket 地址<br>但通常服务器需要，客户端不需要<br>不绑定地址时，自动分配端口+本机地址填充 socket 地址</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> backlog)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> BACKLOG=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(listen(sockfd,BACKLOG)==<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"listen error\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><p>用于 TCP 的通信，只能应用于面向连接的 socket SOCK_STREAM<br>执行 listen 后 socket 转换成被动 socket，可以接受连接</p>
<h4 id="请求队列"><a href="#请求队列" class="headerlink" title="请求队列"></a>请求队列</h4><p>当一个请求到达时，被插入请求队列<br>服务器用 accept 函数从队列中移走并响应请求<br>注意请求队列中的连接已经被TCP接受（即三次握手已经完成），但还没有被应用层所接受<br>注意区分TCP接受一个连接是将其放入这个队列，而应用层接受连接是将其从该队列移出<br>对于新的连接请求，如果连接请求队列中已没有空间，TCP将不理会收到的SYN，也不发回任何报文段（即不回送RST）；<br>为什么不回送RST呢？<br>因为这是一个软错误，通常队列满是由于应用程序或操作系统忙造成的，这个条件在一个很短的时间内可以改变，如果回送RST会将客户进程的主动打开被废弃，不如让它重复发送SYN效率高</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr*servaddr,<span class="keyword">int</span> addrlen)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h4><p>sockfd－socket描述符<br>servaddr－服务器地址<br>addrlen－地址结构长度</p>
<h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><p>0－成功<br>-1－失败<br>errno-为错误代码</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接服务器，调用前需要对srvaddr进行初始化</span></span><br><span class="line">If (connect(sockfd,(struct sockaddr *)&amp;srvaddr,<span class="keyword">sizeof</span>(struct sockaddr))==<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"connect error\n"</span>);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h4><p>用于 TCP 的通信<br>客户机一般不指定自己的端口号，由系统分配一个临时端口<br>填入的地址是远程服务器的地址<br>对一个socket描述符不能两次使用connect函数 </p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr*clientaddr,<span class="keyword">int</span> *addrlen)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h4><p>描述符<br>客户端地址<br>地址结构长度</p>
<h4 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h4><p>大于0 新的 socket 描述符标识已接受的连接<br>-1:没有连接请求到达</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sin_size=<span class="keyword">sizeof</span>(struct sockaddr_in);    </span><br><span class="line"><span class="keyword">int</span> new_fd=accept(sockfd,(struct sockaddr *)&amp;clientaddr,&amp;sin_size) ;    </span><br><span class="line"><span class="keyword">if</span> (new_fd==<span class="number">-1</span>)&#123;       </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"accept error\n"</span>);   </span><br><span class="line">    <span class="keyword">continue</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h4><p>accept 函数在无连接请求时将阻塞进程，并返回-1</p>
<h4 id="用于通信的套接字描述符"><a href="#用于通信的套接字描述符" class="headerlink" title="用于通信的套接字描述符"></a>用于通信的套接字描述符</h4><p>accept 返回的描述符是真正可以和客户端通信的socket<br>服务器的侦听 socket 只负责侦听和接受连接,不负责通信<br>accept新创建的socket的端口号和原sockfd的端口号相同吗？<br>相同！四元组区分TCP连接；主监听套接字和新创建的套接字状态不同（listen/established)<br>处于established的套接字不能接收SYN报文段，而处于listen的套接字不能接收数据报文段。</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span>* buf,<span class="keyword">int</span> len)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h4><p>描述符<br>数据缓冲区<br>读取数据大小</p>
<h4 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h4><p>无数据       阻塞<br>套接字缓冲区&gt;=len   读出len个字节<br>n&gt;0 and n &lt; len     读出n个字节<br>n=0               读通道已关闭<br>n&lt;0               出错或异常，errno为错误代码<br>n=-1,EINTR    由中断引起错误<br>n=-1,ECONNREST  网络连接有问题</p>
<h4 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h4><p>一般用于 TCP 的通信<br>跨越用户态内核态</p>
<h4 id="接收缓冲区"><a href="#接收缓冲区" class="headerlink" title="接收缓冲区"></a>接收缓冲区</h4><p>buf指的是接收或发送进程的应用缓冲区<br>每个TCP套接字都有一个套接字接收缓冲区和发送缓冲区（内核中）<br>分别用于存放即将从网络读或写向网络的数据<br>read并不是从网络读取数据，而只是完成从套接字接收缓冲区到接收进程应用缓冲区复制数据的任务<br>真正从套接字缓冲区到网络读写数据的过程由内核TCP协议来完成，不需要应用程序干涉，系统调用层面不会给予应用程序任何保证和通知；<br>read/write跨越了用户态和内核态，本质是读写系统（内核）缓冲区</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span>* buf,<span class="keyword">int</span> len)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h4><p>描述符<br>数据缓冲区<br>读取数据大小</p>
<h4 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h4><p>无缓冲区        阻塞<br>套接字缓冲区&gt;=len 写入len个字节<br>n&gt;0 and n &lt; len   写入n个字节<br>n=0             写通道已关闭<br>n&lt;0             出错或异常，errno为错误代码<br>n=-1,EINTR  由中断引起错误<br>n=-1,EPIPE      网络连接有问题</p>
<h4 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h4><p>一般用于 TCP 的通信<br>跨越用户态内核态<br>write 函数返回成功不代表数据已经发送至对方主机<br>只说明已经存在发送缓冲区中，等待TCP协议来发送</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="send"><a href="#send" class="headerlink" title="send"></a>send</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf,<span class="keyword">int</span> len,<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="flag-参数"><a href="#flag-参数" class="headerlink" title="flag 参数"></a>flag 参数</h4><p>flags=0, send与write功能相同<br>flags=MSG_DONTROUTE，告诉内核目标主机在本地网络，无需查找路由表。适用于局域网或同一网段<br>flags=MSG_OOB，发送带外数据<br>flags=MSG_DONTWAIT，如果套接字缓冲区没有足够空间，则进程不阻塞等待</p>
<h4 id="说明-6"><a href="#说明-6" class="headerlink" title="说明"></a>说明</h4><p>既可以用于 TCP 也可以 UDP<br>但个人感觉用于 TCP 较好，需先 connect<br>比 write 功能强大，拥有 flag 参数</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h1 id="sendto"><a href="#sendto" class="headerlink" title="sendto"></a>sendto</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf,<span class="keyword">int</span> len,<span class="keyword">int</span> flags,struct sockaddr *toaddr, <span class="keyword">int</span> addrlen)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="flag-参数-1"><a href="#flag-参数-1" class="headerlink" title="flag 参数"></a>flag 参数</h4><p>flags=0, send与write功能相同<br>flags=MSG_DONTROUTE，告诉内核目标主机在本地网络，无需查找路由表。适用于局域网或同一网段<br>flags=MSG_OOB，发送带外数据<br>flags=MSG_DONTWAIT，如果套接字缓冲区没有足够空间，则进程不阻塞等待</p>
<h4 id="说明-7"><a href="#说明-7" class="headerlink" title="说明"></a>说明</h4><p>只能用于 UDP 的无连接通讯<br>需指定目的地址</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="recv"><a href="#recv" class="headerlink" title="recv"></a>recv</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf,<span class="keyword">int</span> len,<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="flag-参数-2"><a href="#flag-参数-2" class="headerlink" title="flag 参数"></a>flag 参数</h4><p>flags=0, recv与read功能相同<br>flags=MSG_OOB，接收带外数据<br>flags=MSG_DONTWAIT，套接字缓冲区没有数据时，进程不阻塞等待<br>flags=MSG_WAITALL，通知内核直到读到请求的数据字节数时，才返回<br>flags=MSG_PEEK，接收数据时不从缓冲区移走数据，下一个读操作将会读到同样的数据</p>
<h4 id="说明-8"><a href="#说明-8" class="headerlink" title="说明"></a>说明</h4><p>既可以用于 TCP 也可以 UDP<br>但个人感觉用于 TCP 较好，需先 connect<br>比 write 功能强大，拥有 flag 参数</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="recvfrom"><a href="#recvfrom" class="headerlink" title="recvfrom"></a>recvfrom</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf,<span class="keyword">int</span> len,<span class="keyword">int</span> flags,struct sockaddr *fromaddr, <span class="keyword">int</span> *addrlen)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="flag-参数-3"><a href="#flag-参数-3" class="headerlink" title="flag 参数"></a>flag 参数</h4><p>flags=0, recv与read功能相同<br>flags=MSG_OOB，接收带外数据<br>flags=MSG_DONTWAIT，套接字缓冲区没有数据时，进程不阻塞等待<br>flags=MSG_WAITALL，通知内核直到读到请求的数据字节数时，才返回<br>flags=MSG_PEEK，接收数据时不从缓冲区移走数据，下一个读操作将会读到同样的数据</p>
<h4 id="说明-9"><a href="#说明-9" class="headerlink" title="说明"></a>说明</h4><p>只能用于 UDP 的无连接通讯<br>一般只声明地址，内核自动填充地址</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="sendmsg-amp-recvmsg"><a href="#sendmsg-amp-recvmsg" class="headerlink" title="sendmsg &amp; recvmsg"></a>sendmsg &amp; recvmsg</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> fd,struct msghdr *msgp,<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recvmsg</span><span class="params">(<span class="keyword">int</span> fd,struct msghdr *msgp,<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能：发送和接收规格化的数据，配对使用<br>返回值：≥0—成功，-1—失败<br>参数：<br>fd－socket描述符<br>msghdr－规格化数据缓冲区<br>flags－控制参数</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="writev-amp-readv"><a href="#writev-amp-readv" class="headerlink" title="writev &amp; readv"></a>writev &amp; readv</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> readv(<span class="keyword">int</span> fd,<span class="keyword">const</span> struct iovec iov[],<span class="keyword">int</span> iovcnt);</span><br><span class="line"><span class="keyword">ssize_t</span> writev(<span class="keyword">int</span> fd,<span class="keyword">const</span> struct iovec iov[],<span class="keyword">int</span> iovcnt);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="keyword">caddr_t</span> iov_base;   <span class="comment">/*缓冲区起始地址*/</span></span><br><span class="line">    <span class="keyword">size_t</span> iov_len;     <span class="comment">/*缓冲区大小*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>功能：一次读、写多个非连续缓冲区<br>返回值：≥0—成功，已读写字节数；-1—失败<br>参数：<br>fd－socket描述符<br>iov－缓冲区数组<br>iovcnt－缓冲区数组个数</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="说明-10"><a href="#说明-10" class="headerlink" title="说明"></a>说明</h4><p>调用 close 后本进程将不能再使用这个套接字<br>但 TCP 可能没有删除套接字结构<br>因为其他进程可能还在使用<br>调用 close 只是对 sockfd 的引用-1<br>直到对 sockfd 的引用为0时才清除 sockfd</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> howto)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="参数-6"><a href="#参数-6" class="headerlink" title="参数"></a>参数</h4><p>sockfd－socket描述符<br>howto－指定关闭操作的类型<br>0：停止读<br>1：停止写<br>2：停止读、写</p>
<h4 id="说明-11"><a href="#说明-11" class="headerlink" title="说明"></a>说明</h4><p>howto=0，关闭读通道，丢弃尚未读取的数据，对后来接收到的数据返回确认后丢弃<br>howto=1，关闭写通道，继续发送发送缓冲区未发送完的数据，然后发送FIN字段关闭写通道<br>howto=2，关闭读写通道，任何进程不能再操作这个socket<br>shutdown关闭连接通道，所有进程不能再使用已被关闭的通道</p>
<h4 id="close-与-shutsown"><a href="#close-与-shutsown" class="headerlink" title="close 与 shutsown"></a>close 与 shutsown</h4><p>关闭对象和影响范围不同：close关闭本进程的sockfd，但链接仍然开着，引用这个sockfd的其它进程还能用这个链接<br>关闭粒度不同：close关闭进程与socket的整个接口，调用close之后本地进程不能再读写这个socket；shutdown可以只关闭一个方向的通道，另一个方向的通道仍然可以操作。</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="getpeername"><a href="#getpeername" class="headerlink" title="getpeername"></a>getpeername</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> fd,struct sockaddr *proaddr,<span class="keyword">int</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="参数-7"><a href="#参数-7" class="headerlink" title="参数"></a>参数</h4><p>fd－socket描述符<br>proaddr－存放地址信息的缓冲区的指针<br>addrlen－存放缓冲区字节数的整型变量的指针<br>返回值：0－成功，－1失败</p>
<h4 id="说明-12"><a href="#说明-12" class="headerlink" title="说明"></a>说明</h4><p>功能：获得对端socket的地址信息<br>当一个调用accept的进程通过fork和exec启动一个新的进程时，经常要调用这个函数；<br>新的服务器通过getpeername函数来得到远端的地址；<br>通常，要在应用的访问地址表查找返回地址，如果返回地址不在访问表中，则连接将被关闭。</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="getsockname"><a href="#getsockname" class="headerlink" title="getsockname"></a>getsockname</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> fd,struct sockaddr *proaddr,<span class="keyword">int</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能：获得本地socket的地址信息<br>参数：<br>fd－socket描述符<br>proaddr－存放地址信息的缓冲区的指针<br>addrlen－存放缓冲区字节数的整型变量的指针<br>返回值：0－成功，－1失败<br>当在bind调用中使用了通配符地址INADDR_ANY时，该函数非常有用</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="getsockopt"><a href="#getsockopt" class="headerlink" title="getsockopt"></a>getsockopt</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">void</span> *optval, <span class="keyword">sock_len_t</span> *optlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">void</span> *optval, <span class="keyword">sock_len_t</span> optlen)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="参数-8"><a href="#参数-8" class="headerlink" title="参数"></a>参数</h4><p>sockfd－socket描述符<br>level－选项级别<br>    SOL_SOCKET —通用socket选项<br>    IPPROTO_TCP—TCP选项<br>    IPPROTO_IP—IP选项<br>optname—选项名称<br>optval—选项值指针<br>optlen—选项值的长度/存放选项值长度的指针  </p>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> listenfd;</span><br><span class="line"><span class="keyword">int</span> on=<span class="number">1</span>;</span><br><span class="line">…</span><br><span class="line">listenfd=socket(AF_INET,TCP_STREAM,<span class="number">0</span>);</span><br><span class="line">setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR,&amp;on,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>
<h4 id="通用socket选项"><a href="#通用socket选项" class="headerlink" title="通用socket选项"></a>通用socket选项</h4><p>SO_KEEPALIVE<br>设置该选项后，一段时间（通常2小时）内没有数据交换时，TCP协议将自动发送探测数据包，检查网络连接<br>SO_RCVBUF和SO_SNDBUF<br>发送和接收数据缓冲区的大小（在连接建立以前设置）<br>SO_RCVTIMEO和SO_SNDTIMEO<br>发送和接收超时，当指定时间内数据没有成功接收或发送，发送和接收函数将返回<br>SO_REUSEADDR<br>一般一个端口释放后会等待两分钟才能被再次使用，该选项可让端口释放后立即就可以被再次使用，这通常在重启监听服务器时可避免bind函数出错<br>允许在同一端口上启动同一服务器的多个实例，只要每个实例捆绑一个不同的本地IP地址即可</p>
<h4 id="IP选项"><a href="#IP选项" class="headerlink" title="IP选项"></a>IP选项</h4><p>IP_HDRINCL－是否在数据缓冲区中包括IP首部，适用于原始socket<br>IP_OPTIONS－IP首部选项<br>IP_TOS－服务类型与优先级<br>IP_TTL－生存时间</p>
<h4 id="TCP选项"><a href="#TCP选项" class="headerlink" title="TCP选项"></a>TCP选项</h4><p>TCP_MAXSEG－TCP协议最大数据段长度<br>TCP_NODELAY－小数据包是否延迟发送（Nagle算法）</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> cmd,…)</span></span></span><br></pre></td></tr></table></figure>
<p>功能：改变套接字属性<br>设置socket为阻塞/非阻塞模式<br>设置允许/不允许接收异步I/O信号<br>设置/获取socket的所有者<br>参数：<br>fd－文件（socket）描述符<br>cmd－执行的操作<br>其他参数－根据cmd选择适当参数<br>返回值：≥0－成功，-1－失败</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> req,…)</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能：控制输入输出<br>参数：<br>fd－文件（socket）描述符<br>req－执行的操作类型<br>第三个参数－总是指针类型，存储操作返回的数据或操作所需的数据<br>返回值：0－成功，-1－失败</p>
<h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例：设置套接字fd为非阻塞方式</span></span><br><span class="line"><span class="keyword">int</span> nIO=<span class="number">1</span>;</span><br><span class="line">ioctl(fd, FIONBIO, &amp;nIO);</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://1t4chi.com/2018/09/14/2018-09-16-Socket API for C/" data-id="cjt6rg51f00125uvqrdudp9jq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/09/14/2018-09-14-Basics of Socket/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Basics of Socket
        
      </div>
    </a>
  
  
    <a href="/2018/09/14/2018-09-15-Socket Address/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Socket Address</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/OS/">OS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Socket/">Socket</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/12/05/Sock_semaphore/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/12/05/2018-10-20-Process Communication_Sharemem/">进程的通信——共享内存</a>
          </li>
        
          <li>
            <a href="/2018/12/05/2018-10-19-Process Communication_Msgqueue/">进程的通信——消息队列</a>
          </li>
        
          <li>
            <a href="/2018/12/05/2018-10-20-Process Communication_Pipe/">进程的通信——管道</a>
          </li>
        
          <li>
            <a href="/2018/12/04/2018-10-11-Socket IO/">Socket 的 IO 模型</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>