<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://1t4chi.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://1t4chi.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2018-10-10-Raw Socket" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/10/2018-10-10-Raw Socket/" class="article-date">
  <time datetime="2018-10-10T01:01:13.000Z" itemprop="datePublished">2018-10-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Socket/">Socket</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/10/2018-10-10-Raw Socket/">原始套接字</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原始套接字能够直接针对 IP 包进行编程;具有更强灵活性;能够直接访问 ICMP,IGMP 等多种协议的数据包。</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="创建-RawSocket"><a href="#创建-RawSocket" class="headerlink" title="创建 RawSocket"></a>创建 RawSocket</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span> <span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li>family: 协议簇 AF_INET,AF_UNIX</li>
<li>type: SOCK_STREAM,SOCK_DGRAM,SOCK_RAW <ul>
<li>TCP 需选 SOCK_STREAM</li>
</ul>
</li>
<li>protocol: 默认为0<ul>
<li>IPPROTO_ICMP－ICMP数据包</li>
<li>IPPROTO_IGMP－IGMP数据包</li>
<li>IPPROTO_IP－IP数据包（内核送达的任意类型IP数据包）</li>
</ul>
</li>
</ul>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>原始套接字是一种非面向连接的套接字<br>且只能由超级用户或系统管理员创建。</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="设置IP选项"><a href="#设置IP选项" class="headerlink" title="设置IP选项"></a>设置IP选项</h2><ul>
<li><p>是否自动填充IP首部，仅影响发送，不影响接收</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> on=<span class="number">1</span>;</span><br><span class="line">setsockopt(sockfd,IPPROTO_IP,IP_HDRINCL,&amp;on,<span class="keyword">sizeof</span>(on));</span><br></pre></td></tr></table></figure>
</li>
<li><p>on=0: 发送缓冲区存放IP数据报的实体部分，由协议自动填充IP首部；</p>
</li>
<li>on=1: 发送缓冲区存放包括IP头部在内的整个IP数据报，用户程序填充IP首部</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://1t4chi.com/2018/10/10/2018-10-10-Raw Socket/" data-id="cjt6rg50f00075uvqe94irq00" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2018-09-28-UDP Model for Socket" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/28/2018-09-28-UDP Model for Socket/" class="article-date">
  <time datetime="2018-09-28T01:44:22.563Z" itemprop="datePublished">2018-09-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Socket/">Socket</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/28/2018-09-28-UDP Model for Socket/">Socket 的 UDP 编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Socket 的 UDP 编程：UDP 协议面向无连接。一般适用于循环服务器模型，但有例外需要灵活掌握。</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="server-一般流程"><a href="#server-一般流程" class="headerlink" title="server 一般流程"></a>server 一般流程</h2><ul>
<li>socket–&gt;bind–&gt;recvfrom–&gt;sendto–&gt;close</li>
<li>没有 listen、accept，只用recvfrom、sendto</li>
<li>socket(AF_INET, SOCK_DGRAM, 0)</li>
<li>bind 自己填入自己的地址用 INADDR_ANY</li>
<li>recvfrom、sendto 只声明，留白等内核自动填入客户端 client 地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 8888</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_LEN 1024</span></span><br></pre></td></tr></table></figure>
<ul>
<li>接收消息的函数 handle_udp_msg</li>
<li>recvfrom是拥塞函数，没有数据就一直拥塞</li>
<li>直到接收到数据后，打印输出</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_udp_msg</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFF_LEN];  <span class="comment">//接收缓冲区，1024字节</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span>  <span class="comment">//client_addr用于记录发送方的地址信息</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFF_LEN);</span><br><span class="line">        len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">        count = recvfrom(fd, buf, BUFF_LEN, <span class="number">0</span>, (struct sockaddr*)&amp;client_addr, &amp;len);  <span class="comment">//recvfrom是拥塞函数，没有数据就一直拥塞</span></span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"recieve data fail!\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"client:%s\n"</span>,buf);  <span class="comment">//打印client发过来的信息</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFF_LEN);</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">"I have recieved %d bytes data!\n"</span>, count);  <span class="comment">//回复client</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"server:%s\n"</span>,buf);  <span class="comment">//打印自己发送的信息给</span></span><br><span class="line">        sendto(fd, buf, BUFF_LEN, <span class="number">0</span>, (struct sockaddr*)&amp;client_addr, len);  <span class="comment">//发送信息给client，注意使用了clent_addr结构体指针</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    server:</span></span><br><span class="line"><span class="comment">            socket--&gt;bind--&gt;recvfrom--&gt;sendto--&gt;close</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_fd, ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ser_addr</span>;</span> </span><br><span class="line"></span><br><span class="line">    server_fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>); <span class="comment">//AF_INET:IPV4;SOCK_DGRAM:UDP</span></span><br><span class="line">    <span class="keyword">if</span>(server_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create socket fail!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ser_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ser_addr));</span><br><span class="line">    ser_addr.sin_family = AF_INET;</span><br><span class="line">    ser_addr.sin_addr.s_addr = htonl(INADDR_ANY); <span class="comment">//IP地址，需要进行网络序转换，INADDR_ANY：本地地址</span></span><br><span class="line">    ser_addr.sin_port = htons(SERVER_PORT);  <span class="comment">//端口号，需要网络序转换</span></span><br><span class="line"></span><br><span class="line">    ret = bind(server_fd, (struct sockaddr*)&amp;ser_addr, <span class="keyword">sizeof</span>(ser_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"socket bind fail!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle_udp_msg(server_fd);   <span class="comment">//处理接收到的数据</span></span><br><span class="line"></span><br><span class="line">    close(server_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="client-一般流程"><a href="#client-一般流程" class="headerlink" title="client 一般流程"></a>client 一般流程</h2><ul>
<li>socket–&gt;sendto–&gt;revcfrom–&gt;close</li>
<li>没有 connect</li>
<li>socket(AF_INET, SOCK_DGRAM, 0)</li>
<li>sendto 自己填入目的服务器 server 的地址</li>
<li>recvfrom 只声明，留白等内核自动填入 server 地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 8888</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_LEN 512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_IP <span class="meta-string">"172.0.5.182"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">udp_msg_sender</span><span class="params">(<span class="keyword">int</span> fd, struct sockaddr* dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">socklen_t</span> len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">src</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFF_LEN] = <span class="string">"TEST UDP MSG!\n"</span>;</span><br><span class="line">        len = <span class="keyword">sizeof</span>(*dst);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"client:%s\n"</span>,buf);  <span class="comment">//打印自己发送的信息</span></span><br><span class="line">        sendto(fd, buf, BUFF_LEN, <span class="number">0</span>, dst, len);</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFF_LEN);</span><br><span class="line">        recvfrom(fd, buf, BUFF_LEN, <span class="number">0</span>, (struct sockaddr*)&amp;src, &amp;len);  <span class="comment">//接收来自server的信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"server:%s\n"</span>,buf);</span><br><span class="line">        sleep(<span class="number">1</span>);  <span class="comment">//一秒发送一次消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    client:</span></span><br><span class="line"><span class="comment">            socket--&gt;sendto--&gt;revcfrom--&gt;close</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> client_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ser_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    client_fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(client_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create socket fail!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ser_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ser_addr));</span><br><span class="line">    ser_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">//ser_addr.sin_addr.s_addr = inet_addr(SERVER_IP);</span></span><br><span class="line">    ser_addr.sin_addr.s_addr = htonl(INADDR_ANY);  <span class="comment">//注意网络序转换</span></span><br><span class="line">    ser_addr.sin_port = htons(SERVER_PORT);  <span class="comment">//注意网络序转换</span></span><br><span class="line"></span><br><span class="line">    udp_msg_sender(client_fd, (struct sockaddr*)&amp;ser_addr);</span><br><span class="line"></span><br><span class="line">    close(client_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="服务器模型"><a href="#服务器模型" class="headerlink" title="服务器模型"></a>服务器模型</h2><h4 id="循环服务器模型"><a href="#循环服务器模型" class="headerlink" title="循环服务器模型"></a>循环服务器模型</h4><p>面向无连接<br>没有一个客户机可以独占服务器<br>处理不对人，对数据报<br>服务器对于每一个客户机的请求能够满足<br>应用层区分数据源</p>
<h4 id="并发服务器模型-客户端请求在一个数据报中完成"><a href="#并发服务器模型-客户端请求在一个数据报中完成" class="headerlink" title="并发服务器模型-客户端请求在一个数据报中完成"></a>并发服务器模型-客户端请求在一个数据报中完成</h4><p>用于客户请求需要较长处理时间且客户发送速度大于服务器处理速度的情况<br>可以避免因接收缓冲区满而导致数据报丢失<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fd=socket</span><br><span class="line">bind(fd)</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    n=recvfrom(fd)</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fork()==<span class="number">0</span>)&#123;</span><br><span class="line">            sendto(fd)</span><br><span class="line">            close(fd)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="模型2－客户端请求在多个数据报中完成"><a href="#模型2－客户端请求在多个数据报中完成" class="headerlink" title="模型2－客户端请求在多个数据报中完成"></a>模型2－客户端请求在多个数据报中完成</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://1t4chi.com/2018/09/28/2018-09-28-UDP Model for Socket/" data-id="cjt6rg50900045uvqx9zjgdkk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2018-09-28-TCP Model for Socket" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/28/2018-09-28-TCP Model for Socket/" class="article-date">
  <time datetime="2018-09-28T01:44:06.935Z" itemprop="datePublished">2018-09-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Socket/">Socket</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/28/2018-09-28-TCP Model for Socket/">Socket 的 TCP 编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Socket 的 TCP 编程：TCP 协议面向连接。一般适用于并发服务器模型，但有例外需要灵活掌握。</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="一般流程"><a href="#一般流程" class="headerlink" title="一般流程"></a>一般流程</h2><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><ul>
<li>socket：<ul>
<li>创建套接字 </li>
<li>TCP 用 fd1 = socket(AF_INET,SOCK_STREAM,0)</li>
<li>获得一个 socket 描述符 fd1</li>
</ul>
</li>
<li>bind：<ul>
<li>绑定服务器自己地址和端口</li>
<li>传入套接字描述符 fd1</li>
<li>传入自己地址用 INADDR_ANY</li>
</ul>
</li>
<li>listen：<ul>
<li>监听端口</li>
<li>传入套接字描述符 fd1</li>
<li>传入最大请求数量</li>
</ul>
</li>
<li>accept：<ul>
<li>接受客户连接</li>
<li>传入地址 <strong>只声明</strong> ，由内核填入客户端地址</li>
<li>获得用于通信的 socket 描述符 fd2</li>
</ul>
</li>
<li>read(recv)：<ul>
<li>接受客户请求</li>
<li>传入用于通信的 socket 描述符 fd2</li>
<li>无需传地址，需要传入接收缓冲区与其长度</li>
</ul>
</li>
<li>write(send)：<ul>
<li>回送响应</li>
<li>传入用于通信的 socket 描述符 fd2</li>
<li>无需传地址，需要传入消息与其长度</li>
</ul>
</li>
<li>close：<ul>
<li>关闭套接字</li>
<li>并发服务器，一次通讯完关闭通讯描述符 fd2</li>
</ul>
</li>
</ul>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>socket：创建套接字，socket(AF_INET,SOCK_STREAM,0)<br>connect：连接服务器，填入远程服务器地址和端口<br>write(send)：客户端发送请求<br>read(recv)：客户端接收响应<br>close：关闭套接字 </p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="服务器模型"><a href="#服务器模型" class="headerlink" title="服务器模型"></a>服务器模型</h2><h4 id="循环服务器模型"><a href="#循环服务器模型" class="headerlink" title="循环服务器模型"></a>循环服务器模型</h4><p>TCP 不常用循环服务器模型</p>
<h4 id="并发服务器模型"><a href="#并发服务器模型" class="headerlink" title="并发服务器模型"></a>并发服务器模型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fd=socket</span><br><span class="line">bind(fd)</span><br><span class="line">listen(fd)</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    newfd=accept(fd)</span><br><span class="line">    <span class="keyword">if</span>(fork()==<span class="number">0</span>)&#123;</span><br><span class="line">        close(fd)</span><br><span class="line">        recv(newfd)</span><br><span class="line">        send(newfd)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    close(newfd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="延迟创建子进程模型"><a href="#延迟创建子进程模型" class="headerlink" title="延迟创建子进程模型"></a>延迟创建子进程模型</h4><p>循环与并发混合的服务器模型<br>处理时间短的客户请求以循环方式完成<br>处理时间长的客户请求以并发方式完成<br>减少创建子进程的开销<br>建立进程表项的开销<br>复制数据段和堆栈段的开销</p>
<h4 id="固定预创建子进程模型"><a href="#固定预创建子进程模型" class="headerlink" title="固定预创建子进程模型"></a>固定预创建子进程模型</h4><p>服务器建立侦听socket，并创建子进程<br>所有子进程调用accept，无连接时将睡眠<br>有连接到来时子进程被唤醒<br>某一个子进程接受连接后，其他进程继续睡眠</p>
<h4 id="动态预创建子进程"><a href="#动态预创建子进程" class="headerlink" title="动态预创建子进程"></a>动态预创建子进程</h4><p>实现过程<br>服务器建立socket，并创建一定数量子进程<br>服务器父进程维护所有子进程的状态表，父进程和子进程通过管道通信<br>子进程接受连接时给父进程发1，关闭连接时发0<br>父进程收到1时检查空闲子进程数目是否小于下限，小于下限则创建新的子进程<br>父进程收到0时检查空闲子进程数目是否大于上限，大于上限则终止一些子进程</p>
<h4 id="多路复用I-O"><a href="#多路复用I-O" class="headerlink" title="多路复用I/O"></a>多路复用I/O</h4><p>原理：<br>int select(int maxfd,fd_set <em>rdset,fd_set </em>wrest,fd_set <em>exset,struct timeval </em>timeout);<br>select函数检查侦听socket是否有连接到达、已连接socket是否有数据到达、已连接socket是否可以写数据<br>在测试是否可读的描述符集合rdset中同时包含侦听socket和已连接socket，在测试是否可写描述符集合中包含已连接socket，就可以实现多路复用<br>设置读和写描述符集合，其中读描述符集合包括侦听socket<br>调用select测试socket描述符是否就绪<br>侦听socket就绪则接收新连接<br>其他socket就绪则执行读写操作<br>重复步骤1－4</p>
<p>优点<br>只需要一个进程来处理所有客户机请求<br>没有创建和管理子进程的开销，系统资源消耗少<br>没有进程间通信<br>缺点<br>服务器必须依次处理所有的请求，编程较复杂<br>服务器循环处理所有就绪客户端，可能会造成延时较长</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://1t4chi.com/2018/09/28/2018-09-28-TCP Model for Socket/" data-id="cjt6rg50b00055uvq1vt3mt2r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2018-10-12-Socket IO_Multiplex" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/21/2018-10-12-Socket IO_Multiplex/" class="article-date">
  <time datetime="2018-09-21T00:50:33.837Z" itemprop="datePublished">2018-09-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Socket/">Socket</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/21/2018-10-12-Socket IO_Multiplex/">多路复用 Socket IO 模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>多路复用模型是阻塞模型的改进。监视多个描述符，一旦某个描述符就绪，就通知程序进行相应操作。</p>
<hr>
<h2 id="回顾阻塞与非阻塞模型"><a href="#回顾阻塞与非阻塞模型" class="headerlink" title="回顾阻塞与非阻塞模型"></a>回顾阻塞与非阻塞模型</h2><h4 id="阻塞方式-block"><a href="#阻塞方式-block" class="headerlink" title="阻塞方式 block"></a>阻塞方式 block</h4><p>顾名思义，就是进程或是线程执行到这些函数时必须等待某个事件的发生，假如事件没有发生，进程或线程就被阻塞，函数不能立即返回。</p>
<h4 id="非阻塞方式-non-block"><a href="#非阻塞方式-non-block" class="headerlink" title="非阻塞方式 non-block"></a>非阻塞方式 non-block</h4><p>就是进程或线程执行此函数时不必非要等待事件的发生，一旦执行肯定返回，以返回值的不同来反映函数的执行情况，假如事件发生则和阻塞方式相同，若事件没有发生则返回一个代码来告知事件未发生，而进程或线程继续执行，所以效率较高。</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="fd-set-数据结构"><a href="#fd-set-数据结构" class="headerlink" title="fd_set 数据结构"></a>fd_set 数据结构</h2><p>是一种数据结构和 int char 一样<br>实际上是一long类型的数组，每一个数组元素都能与一打开的文件句柄<br>(不管是socket句柄，还是其他文件或命名管道或设备句柄)建立联系<br>建立联系的工作由程序员完成<br>当调用select()时，由内核根据IO状态修改fe_set的内容<br>由此来通知执行了select()的进程哪一socket或文件可读。<br>可简单描述为（实际很复杂）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedefstruct fd_set &#123;</span><br><span class="line">　u_int fd_count;</span><br><span class="line">　socket fd_array[FD_SETSIZE];</span><br><span class="line">&#125; fd_set;</span><br></pre></td></tr></table></figure>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfd,fd_set *rdset,fd_set *wrest,fd_set *exset,struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> tv_sec;<span class="comment">//秒</span></span><br><span class="line">    <span class="keyword">long</span> tv_usec;<span class="comment">//微秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>检查多个文件描述符（socket描述符）是否就绪<br>当某一个描述符就绪（可读、可写或发生异常）时函数返回<br>可以实现输入输出多路复用</p>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>有描述符就绪则返回就绪的描述符个数<br>超时时间内没有描述符就绪返回0<br>执行失败返回 -1。</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>maxfd－集合中所有描述符的最大值+1<br>rdset－需要测试是否可读的描述符集合（包括处于listen状态的socket接收到连接请求）<br>wrset－需要测试是否可写的描述符集合（包括以非阻塞方式调用connect是否成功）<br>exset－需要测试是否异常的描述符集合（包括接收带外数据的socket有带外数据到达）<br>timeout－指定测试超时的时间 </p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="描述符集合操作函数"><a href="#描述符集合操作函数" class="headerlink" title="描述符集合操作函数"></a>描述符集合操作函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FD_ZERO(fd_set *fdset) <span class="comment">//清空描述符集合</span></span><br><span class="line">FD_SET(<span class="keyword">int</span> fd,fd_set *fdset) <span class="comment">//将一个描述符添加到描述符集合 </span></span><br><span class="line">FD_CLR(<span class="keyword">int</span> fd,fd_set *fdset) <span class="comment">//将一个描述符从描述符集合中清除 </span></span><br><span class="line">FD_ISSET(<span class="keyword">int</span> fd,fd_set *fdset) <span class="comment">//检测一个描述符是否就绪</span></span><br></pre></td></tr></table></figure>
<h4 id="FD-ZERO-初始化操作"><a href="#FD-ZERO-初始化操作" class="headerlink" title="FD_ZERO 初始化操作"></a>FD_ZERO 初始化操作</h4><p>是把集合清空（初始化为0，确切的说，是把集合中的元素个数初始化为0，并不修改描述符数组).使用集合前，必须用FD_ZERO初始化，否则集合在栈上作为自动变量分配时，fd_set分配的将是随机值，导致不可预测的问题。<br>注：在设置描述符集合前应该先调用FD_ZERO将集合清空，每次调用select函数前应该重新设置读、写和错误3个集合；三个集合中的描述符可以交叉 </p>
<h4 id="FD-SET-添加操作"><a href="#FD-SET-添加操作" class="headerlink" title="FD_SET 添加操作"></a>FD_SET 添加操作</h4><p>向集合中加入一个套接口描述符（如果该套接口描述符s没在集合中，并且数组中已经设置的个数小于最大个数时，就把该描述符加入到集合中，集合元素个数加1）。这里是将s的值直接放入数组中。</p>
<h4 id="FD-CLR-清除操作"><a href="#FD-CLR-清除操作" class="headerlink" title="FD_CLR 清除操作"></a>FD_CLR 清除操作</h4><p>从集合中移出一个套接字描述符（比如一个套接字连接中断后，就应该移除它）。实现思路是，在数组集合中找到对应的描述符，然后把后面的描述依次前移一个位置，最后把描述符的个数减1。</p>
<h4 id="FD-ISSET-匹配操作"><a href="#FD-ISSET-匹配操作" class="headerlink" title="FD_ISSET 匹配操作"></a>FD_ISSET 匹配操作</h4><p>检查描述符是否在集合中，如果在集合中返回非0值，否则返回0. 它的宏定义并没有给出具体实现，但实现的思路很简单，就是搜索集合，判断套接字s是否在数组中。</p>
<h4 id="调用规则"><a href="#调用规则" class="headerlink" title="调用规则"></a>调用规则</h4><p>调用FD_ZERO来初始化fd_set；<br>调用FD_SET将感兴趣的套接字描述符加入fd_set集合中（每次循环都要重新加入，因为select更新后，会将一些没有满足条件的套接字移除队列）；<br>设置等待时间后，调用select函数–更新套接字的状态；<br>调用FD_ISSET，来判断套接字是否有相应状态，然后做相应操作，比如，如果套接字可读，就调用recv函数去接收数据。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fd_set <span class="built_in">set</span>;</span><br><span class="line"><span class="comment">// 注意：fd的最大值必须&lt;FD_SETSIZE</span></span><br><span class="line">FD_ZERO(&amp;<span class="built_in">set</span>);        </span><br><span class="line"><span class="comment">// 将set的所有位置0，如set在内存中占8位则将set置为00000000</span></span><br><span class="line">FD_SET(<span class="number">0</span>, &amp;<span class="built_in">set</span>);       </span><br><span class="line"><span class="comment">//将set的第0位置1，如set原来是00000000，则现在变为10000，这样fd==1的文件描述字就被加进set中了</span></span><br><span class="line">FD_CLR(<span class="number">4</span>, &amp;<span class="built_in">set</span>);       </span><br><span class="line"><span class="comment">//将set的第4位置0，如set原来是10001000，则现在变为10000000，这样fd==4的文件描述字就被从set中清除了</span></span><br><span class="line">FD_ISSET(<span class="number">5</span>, &amp;<span class="built_in">set</span>);     </span><br><span class="line"><span class="comment">//测试set的第5位是否为1，如果原来set是10000100，则返回非零，表明fd==5的文件描述符在set中，否则返回0</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://1t4chi.com/2018/09/21/2018-10-12-Socket IO_Multiplex/" data-id="cjt6rg50m000b5uvqnqh4rzd9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2018-09-14-Basics of Socket" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/14/2018-09-14-Basics of Socket/" class="article-date">
  <time datetime="2018-09-14T01:30:09.527Z" itemprop="datePublished">2018-09-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Socket/">Socket</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/14/2018-09-14-Basics of Socket/">Basics of Socket</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Socket 是一种不可见控件，是应用程序间进行数据传输的端节点;是连接应用程序和底层协议栈的接口;是因特网上程序间进行数据传输的一个断点。应用程序间进行数据传输通过 socket 进行。</p>
<hr>
<h2 id="支持协议簇"><a href="#支持协议簇" class="headerlink" title="支持协议簇"></a>支持协议簇</h2><p>支持多种协议簇，对应不同寻址方式<br>socket 地址: IP 地址+端口号<br>UNIX UNIX 域<br>INET TCPIP</p>
<hr>
<h2 id="标识"><a href="#标识" class="headerlink" title="标识"></a>标识</h2><ul>
<li>五元组&lt;sIP,sPort,dIP,dPort,Pro&gt;  </li>
<li>本地 IP  </li>
<li>本地端口 1024-5000  </li>
<li>远程 IP  </li>
<li>远程端口 1-1023  </li>
<li>协议类型 </li>
</ul>
<hr>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ul>
<li>流式套接字 Stream socket interface TCP 可靠的双向顺序数据流连接</li>
<li>数据包套接字 Datagram socket interface UDP 不可靠的双向数据传输</li>
<li>原始套接字 Raw socket interface IP 允许进程直接存取下层协议</li>
</ul>
<hr>
<h2 id="查看连接"><a href="#查看连接" class="headerlink" title="查看连接"></a>查看连接</h2><ul>
<li>Netstat 命令用于显示各种网络相关信息</li>
<li>如网络连接，路由表，接口状态，masquerade 连接，多播成员等等</li>
<li>netstat -an</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://1t4chi.com/2018/09/14/2018-09-14-Basics of Socket/" data-id="cjt6rg50700035uvqmja47jwq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2018-09-16-Socket API for C" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/14/2018-09-16-Socket API for C/" class="article-date">
  <time datetime="2018-09-14T01:25:53.000Z" itemprop="datePublished">2018-09-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Socket/">Socket</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/14/2018-09-16-Socket API for C/">C 语言的 Socket 编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>C 语言下的 Socket 常用接口: 包括创建、绑定、监听、连接、读写等等。</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> family,<span class="keyword">int</span> type,<span class="keyword">int</span> protocol)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li>family: 协议簇 AF_INET,AF_UNIX</li>
<li>type: <ul>
<li>SOCK_STREAM:TCP</li>
<li>SOCK_DGRAM:UDP</li>
<li>SOCK_RAW:IP</li>
</ul>
</li>
<li>protocol: 默认为0</li>
</ul>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>大于0-socket描述符，-1-失败 </p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sockfd=socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(sockfd==<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Cannot create socket\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>并不是上面的type和protocol可以随意组合的<br>如SOCK_STREAM不可以跟IPPROTO_UDP组合<br>当protocol为0时，会自动选择type类型对应的默认协议</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr * myaddr,<span class="keyword">int</span> addrlen)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><p>sockfd socket 描述符<br>myaddr 一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，<br>addrlen 地址长度</p>
<h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>大于0<br>-1</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(bind(sockfd,(struct sockaddr*)&amp;srvaddr,sizrof(truct sockaddr))==<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Bind error\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><p><strong>不会产生阻塞</strong><br>客户端与服务器都可以绑定 socket 地址<br>但通常服务器需要，客户端不需要<br>不绑定地址时，自动分配端口+本机地址填充 socket 地址</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> backlog)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> BACKLOG=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(listen(sockfd,BACKLOG)==<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"listen error\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><p>用于 TCP 的通信，只能应用于面向连接的 socket SOCK_STREAM<br>执行 listen 后 socket 转换成被动 socket，可以接受连接</p>
<h4 id="请求队列"><a href="#请求队列" class="headerlink" title="请求队列"></a>请求队列</h4><p>当一个请求到达时，被插入请求队列<br>服务器用 accept 函数从队列中移走并响应请求<br>注意请求队列中的连接已经被TCP接受（即三次握手已经完成），但还没有被应用层所接受<br>注意区分TCP接受一个连接是将其放入这个队列，而应用层接受连接是将其从该队列移出<br>对于新的连接请求，如果连接请求队列中已没有空间，TCP将不理会收到的SYN，也不发回任何报文段（即不回送RST）；<br>为什么不回送RST呢？<br>因为这是一个软错误，通常队列满是由于应用程序或操作系统忙造成的，这个条件在一个很短的时间内可以改变，如果回送RST会将客户进程的主动打开被废弃，不如让它重复发送SYN效率高</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr*servaddr,<span class="keyword">int</span> addrlen)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h4><p>sockfd－socket描述符<br>servaddr－服务器地址<br>addrlen－地址结构长度</p>
<h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><p>0－成功<br>-1－失败<br>errno-为错误代码</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接服务器，调用前需要对srvaddr进行初始化</span></span><br><span class="line">If (connect(sockfd,(struct sockaddr *)&amp;srvaddr,<span class="keyword">sizeof</span>(struct sockaddr))==<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"connect error\n"</span>);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h4><p>用于 TCP 的通信<br>客户机一般不指定自己的端口号，由系统分配一个临时端口<br>填入的地址是远程服务器的地址<br>对一个socket描述符不能两次使用connect函数 </p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr*clientaddr,<span class="keyword">int</span> *addrlen)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h4><p>描述符<br>客户端地址<br>地址结构长度</p>
<h4 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h4><p>大于0 新的 socket 描述符标识已接受的连接<br>-1:没有连接请求到达</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sin_size=<span class="keyword">sizeof</span>(struct sockaddr_in);    </span><br><span class="line"><span class="keyword">int</span> new_fd=accept(sockfd,(struct sockaddr *)&amp;clientaddr,&amp;sin_size) ;    </span><br><span class="line"><span class="keyword">if</span> (new_fd==<span class="number">-1</span>)&#123;       </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"accept error\n"</span>);   </span><br><span class="line">    <span class="keyword">continue</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h4><p>accept 函数在无连接请求时将阻塞进程，并返回-1</p>
<h4 id="用于通信的套接字描述符"><a href="#用于通信的套接字描述符" class="headerlink" title="用于通信的套接字描述符"></a>用于通信的套接字描述符</h4><p>accept 返回的描述符是真正可以和客户端通信的socket<br>服务器的侦听 socket 只负责侦听和接受连接,不负责通信<br>accept新创建的socket的端口号和原sockfd的端口号相同吗？<br>相同！四元组区分TCP连接；主监听套接字和新创建的套接字状态不同（listen/established)<br>处于established的套接字不能接收SYN报文段，而处于listen的套接字不能接收数据报文段。</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span>* buf,<span class="keyword">int</span> len)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h4><p>描述符<br>数据缓冲区<br>读取数据大小</p>
<h4 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h4><p>无数据       阻塞<br>套接字缓冲区&gt;=len   读出len个字节<br>n&gt;0 and n &lt; len     读出n个字节<br>n=0               读通道已关闭<br>n&lt;0               出错或异常，errno为错误代码<br>n=-1,EINTR    由中断引起错误<br>n=-1,ECONNREST  网络连接有问题</p>
<h4 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h4><p>一般用于 TCP 的通信<br>跨越用户态内核态</p>
<h4 id="接收缓冲区"><a href="#接收缓冲区" class="headerlink" title="接收缓冲区"></a>接收缓冲区</h4><p>buf指的是接收或发送进程的应用缓冲区<br>每个TCP套接字都有一个套接字接收缓冲区和发送缓冲区（内核中）<br>分别用于存放即将从网络读或写向网络的数据<br>read并不是从网络读取数据，而只是完成从套接字接收缓冲区到接收进程应用缓冲区复制数据的任务<br>真正从套接字缓冲区到网络读写数据的过程由内核TCP协议来完成，不需要应用程序干涉，系统调用层面不会给予应用程序任何保证和通知；<br>read/write跨越了用户态和内核态，本质是读写系统（内核）缓冲区</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span>* buf,<span class="keyword">int</span> len)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h4><p>描述符<br>数据缓冲区<br>读取数据大小</p>
<h4 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h4><p>无缓冲区        阻塞<br>套接字缓冲区&gt;=len 写入len个字节<br>n&gt;0 and n &lt; len   写入n个字节<br>n=0             写通道已关闭<br>n&lt;0             出错或异常，errno为错误代码<br>n=-1,EINTR  由中断引起错误<br>n=-1,EPIPE      网络连接有问题</p>
<h4 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h4><p>一般用于 TCP 的通信<br>跨越用户态内核态<br>write 函数返回成功不代表数据已经发送至对方主机<br>只说明已经存在发送缓冲区中，等待TCP协议来发送</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="send"><a href="#send" class="headerlink" title="send"></a>send</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf,<span class="keyword">int</span> len,<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="flag-参数"><a href="#flag-参数" class="headerlink" title="flag 参数"></a>flag 参数</h4><p>flags=0, send与write功能相同<br>flags=MSG_DONTROUTE，告诉内核目标主机在本地网络，无需查找路由表。适用于局域网或同一网段<br>flags=MSG_OOB，发送带外数据<br>flags=MSG_DONTWAIT，如果套接字缓冲区没有足够空间，则进程不阻塞等待</p>
<h4 id="说明-6"><a href="#说明-6" class="headerlink" title="说明"></a>说明</h4><p>既可以用于 TCP 也可以 UDP<br>但个人感觉用于 TCP 较好，需先 connect<br>比 write 功能强大，拥有 flag 参数</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h1 id="sendto"><a href="#sendto" class="headerlink" title="sendto"></a>sendto</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf,<span class="keyword">int</span> len,<span class="keyword">int</span> flags,struct sockaddr *toaddr, <span class="keyword">int</span> addrlen)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="flag-参数-1"><a href="#flag-参数-1" class="headerlink" title="flag 参数"></a>flag 参数</h4><p>flags=0, send与write功能相同<br>flags=MSG_DONTROUTE，告诉内核目标主机在本地网络，无需查找路由表。适用于局域网或同一网段<br>flags=MSG_OOB，发送带外数据<br>flags=MSG_DONTWAIT，如果套接字缓冲区没有足够空间，则进程不阻塞等待</p>
<h4 id="说明-7"><a href="#说明-7" class="headerlink" title="说明"></a>说明</h4><p>只能用于 UDP 的无连接通讯<br>需指定目的地址</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="recv"><a href="#recv" class="headerlink" title="recv"></a>recv</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf,<span class="keyword">int</span> len,<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="flag-参数-2"><a href="#flag-参数-2" class="headerlink" title="flag 参数"></a>flag 参数</h4><p>flags=0, recv与read功能相同<br>flags=MSG_OOB，接收带外数据<br>flags=MSG_DONTWAIT，套接字缓冲区没有数据时，进程不阻塞等待<br>flags=MSG_WAITALL，通知内核直到读到请求的数据字节数时，才返回<br>flags=MSG_PEEK，接收数据时不从缓冲区移走数据，下一个读操作将会读到同样的数据</p>
<h4 id="说明-8"><a href="#说明-8" class="headerlink" title="说明"></a>说明</h4><p>既可以用于 TCP 也可以 UDP<br>但个人感觉用于 TCP 较好，需先 connect<br>比 write 功能强大，拥有 flag 参数</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="recvfrom"><a href="#recvfrom" class="headerlink" title="recvfrom"></a>recvfrom</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf,<span class="keyword">int</span> len,<span class="keyword">int</span> flags,struct sockaddr *fromaddr, <span class="keyword">int</span> *addrlen)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="flag-参数-3"><a href="#flag-参数-3" class="headerlink" title="flag 参数"></a>flag 参数</h4><p>flags=0, recv与read功能相同<br>flags=MSG_OOB，接收带外数据<br>flags=MSG_DONTWAIT，套接字缓冲区没有数据时，进程不阻塞等待<br>flags=MSG_WAITALL，通知内核直到读到请求的数据字节数时，才返回<br>flags=MSG_PEEK，接收数据时不从缓冲区移走数据，下一个读操作将会读到同样的数据</p>
<h4 id="说明-9"><a href="#说明-9" class="headerlink" title="说明"></a>说明</h4><p>只能用于 UDP 的无连接通讯<br>一般只声明地址，内核自动填充地址</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="sendmsg-amp-recvmsg"><a href="#sendmsg-amp-recvmsg" class="headerlink" title="sendmsg &amp; recvmsg"></a>sendmsg &amp; recvmsg</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> fd,struct msghdr *msgp,<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recvmsg</span><span class="params">(<span class="keyword">int</span> fd,struct msghdr *msgp,<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能：发送和接收规格化的数据，配对使用<br>返回值：≥0—成功，-1—失败<br>参数：<br>fd－socket描述符<br>msghdr－规格化数据缓冲区<br>flags－控制参数</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="writev-amp-readv"><a href="#writev-amp-readv" class="headerlink" title="writev &amp; readv"></a>writev &amp; readv</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> readv(<span class="keyword">int</span> fd,<span class="keyword">const</span> struct iovec iov[],<span class="keyword">int</span> iovcnt);</span><br><span class="line"><span class="keyword">ssize_t</span> writev(<span class="keyword">int</span> fd,<span class="keyword">const</span> struct iovec iov[],<span class="keyword">int</span> iovcnt);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="keyword">caddr_t</span> iov_base;   <span class="comment">/*缓冲区起始地址*/</span></span><br><span class="line">    <span class="keyword">size_t</span> iov_len;     <span class="comment">/*缓冲区大小*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>功能：一次读、写多个非连续缓冲区<br>返回值：≥0—成功，已读写字节数；-1—失败<br>参数：<br>fd－socket描述符<br>iov－缓冲区数组<br>iovcnt－缓冲区数组个数</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="说明-10"><a href="#说明-10" class="headerlink" title="说明"></a>说明</h4><p>调用 close 后本进程将不能再使用这个套接字<br>但 TCP 可能没有删除套接字结构<br>因为其他进程可能还在使用<br>调用 close 只是对 sockfd 的引用-1<br>直到对 sockfd 的引用为0时才清除 sockfd</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> howto)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="参数-6"><a href="#参数-6" class="headerlink" title="参数"></a>参数</h4><p>sockfd－socket描述符<br>howto－指定关闭操作的类型<br>0：停止读<br>1：停止写<br>2：停止读、写</p>
<h4 id="说明-11"><a href="#说明-11" class="headerlink" title="说明"></a>说明</h4><p>howto=0，关闭读通道，丢弃尚未读取的数据，对后来接收到的数据返回确认后丢弃<br>howto=1，关闭写通道，继续发送发送缓冲区未发送完的数据，然后发送FIN字段关闭写通道<br>howto=2，关闭读写通道，任何进程不能再操作这个socket<br>shutdown关闭连接通道，所有进程不能再使用已被关闭的通道</p>
<h4 id="close-与-shutsown"><a href="#close-与-shutsown" class="headerlink" title="close 与 shutsown"></a>close 与 shutsown</h4><p>关闭对象和影响范围不同：close关闭本进程的sockfd，但链接仍然开着，引用这个sockfd的其它进程还能用这个链接<br>关闭粒度不同：close关闭进程与socket的整个接口，调用close之后本地进程不能再读写这个socket；shutdown可以只关闭一个方向的通道，另一个方向的通道仍然可以操作。</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="getpeername"><a href="#getpeername" class="headerlink" title="getpeername"></a>getpeername</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> fd,struct sockaddr *proaddr,<span class="keyword">int</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="参数-7"><a href="#参数-7" class="headerlink" title="参数"></a>参数</h4><p>fd－socket描述符<br>proaddr－存放地址信息的缓冲区的指针<br>addrlen－存放缓冲区字节数的整型变量的指针<br>返回值：0－成功，－1失败</p>
<h4 id="说明-12"><a href="#说明-12" class="headerlink" title="说明"></a>说明</h4><p>功能：获得对端socket的地址信息<br>当一个调用accept的进程通过fork和exec启动一个新的进程时，经常要调用这个函数；<br>新的服务器通过getpeername函数来得到远端的地址；<br>通常，要在应用的访问地址表查找返回地址，如果返回地址不在访问表中，则连接将被关闭。</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="getsockname"><a href="#getsockname" class="headerlink" title="getsockname"></a>getsockname</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> fd,struct sockaddr *proaddr,<span class="keyword">int</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能：获得本地socket的地址信息<br>参数：<br>fd－socket描述符<br>proaddr－存放地址信息的缓冲区的指针<br>addrlen－存放缓冲区字节数的整型变量的指针<br>返回值：0－成功，－1失败<br>当在bind调用中使用了通配符地址INADDR_ANY时，该函数非常有用</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="getsockopt"><a href="#getsockopt" class="headerlink" title="getsockopt"></a>getsockopt</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">void</span> *optval, <span class="keyword">sock_len_t</span> *optlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">void</span> *optval, <span class="keyword">sock_len_t</span> optlen)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="参数-8"><a href="#参数-8" class="headerlink" title="参数"></a>参数</h4><p>sockfd－socket描述符<br>level－选项级别<br>    SOL_SOCKET —通用socket选项<br>    IPPROTO_TCP—TCP选项<br>    IPPROTO_IP—IP选项<br>optname—选项名称<br>optval—选项值指针<br>optlen—选项值的长度/存放选项值长度的指针  </p>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> listenfd;</span><br><span class="line"><span class="keyword">int</span> on=<span class="number">1</span>;</span><br><span class="line">…</span><br><span class="line">listenfd=socket(AF_INET,TCP_STREAM,<span class="number">0</span>);</span><br><span class="line">setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR,&amp;on,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>
<h4 id="通用socket选项"><a href="#通用socket选项" class="headerlink" title="通用socket选项"></a>通用socket选项</h4><p>SO_KEEPALIVE<br>设置该选项后，一段时间（通常2小时）内没有数据交换时，TCP协议将自动发送探测数据包，检查网络连接<br>SO_RCVBUF和SO_SNDBUF<br>发送和接收数据缓冲区的大小（在连接建立以前设置）<br>SO_RCVTIMEO和SO_SNDTIMEO<br>发送和接收超时，当指定时间内数据没有成功接收或发送，发送和接收函数将返回<br>SO_REUSEADDR<br>一般一个端口释放后会等待两分钟才能被再次使用，该选项可让端口释放后立即就可以被再次使用，这通常在重启监听服务器时可避免bind函数出错<br>允许在同一端口上启动同一服务器的多个实例，只要每个实例捆绑一个不同的本地IP地址即可</p>
<h4 id="IP选项"><a href="#IP选项" class="headerlink" title="IP选项"></a>IP选项</h4><p>IP_HDRINCL－是否在数据缓冲区中包括IP首部，适用于原始socket<br>IP_OPTIONS－IP首部选项<br>IP_TOS－服务类型与优先级<br>IP_TTL－生存时间</p>
<h4 id="TCP选项"><a href="#TCP选项" class="headerlink" title="TCP选项"></a>TCP选项</h4><p>TCP_MAXSEG－TCP协议最大数据段长度<br>TCP_NODELAY－小数据包是否延迟发送（Nagle算法）</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> cmd,…)</span></span></span><br></pre></td></tr></table></figure>
<p>功能：改变套接字属性<br>设置socket为阻塞/非阻塞模式<br>设置允许/不允许接收异步I/O信号<br>设置/获取socket的所有者<br>参数：<br>fd－文件（socket）描述符<br>cmd－执行的操作<br>其他参数－根据cmd选择适当参数<br>返回值：≥0－成功，-1－失败</p>
<hr>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> req,…)</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能：控制输入输出<br>参数：<br>fd－文件（socket）描述符<br>req－执行的操作类型<br>第三个参数－总是指针类型，存储操作返回的数据或操作所需的数据<br>返回值：0－成功，-1－失败</p>
<h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例：设置套接字fd为非阻塞方式</span></span><br><span class="line"><span class="keyword">int</span> nIO=<span class="number">1</span>;</span><br><span class="line">ioctl(fd, FIONBIO, &amp;nIO);</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://1t4chi.com/2018/09/14/2018-09-16-Socket API for C/" data-id="cjt6rg51f00125uvqrdudp9jq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2018-09-15-Socket Address" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/14/2018-09-15-Socket Address/" class="article-date">
  <time datetime="2018-09-14T01:21:55.011Z" itemprop="datePublished">2018-09-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Socket/">Socket</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/14/2018-09-15-Socket Address/">Socket Address</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="套接字地址"><a href="#套接字地址" class="headerlink" title="套接字地址"></a>套接字地址</h1><h2 id="地址结构体"><a href="#地址结构体" class="headerlink" title="地址结构体"></a>地址结构体</h2><h4 id="sockaddr-in"><a href="#sockaddr-in" class="headerlink" title="sockaddr_in"></a>sockaddr_in</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">　　<span class="keyword">short</span> <span class="keyword">int</span> sin_family; <span class="comment">/* Address family */</span></span><br><span class="line">　　<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sin_port; <span class="comment">/* Port number */</span></span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* Internet address */</span></span><br><span class="line">　　<span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">/* Same size as struct sockaddr */</span></span><br><span class="line">　　&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">　　<span class="keyword">union</span> &#123;</span><br><span class="line">　　<span class="class"><span class="keyword">struct</span>&#123;</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> s_b1,s_b2, s_b3,s_b4;&#125; S_un_b;</span><br><span class="line">　　<span class="class"><span class="keyword">struct</span>&#123;</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> s_w1, s_w2;&#125; S_un_w;</span><br><span class="line">　　<span class="keyword">unsigned</span> <span class="keyword">long</span> s_addr;</span><br><span class="line">　　&#125; S_un;</span><br><span class="line">　　&#125; IN_ADDR;</span><br></pre></td></tr></table></figure>
<h4 id="协议簇-sin-family"><a href="#协议簇-sin-family" class="headerlink" title="协议簇 sin_family"></a>协议簇 sin_family</h4><p>一般有：AF_INET(IPV4)、AF_INET6(IPV6)、AF_UNSPEC<br>如果指定AF_INET，那么函数就不能返回任何IPV6相关的地址信息<br>如果仅指定了AF_INET6，则就不能返回任何IPV4地址信息。<br>AF_UNSPEC则意味着函数返回的是适用于指定主机名和服务名且适合任何协议族的地址<br>如果某个主机既有AAAA记录(IPV6)地址，同时又有A记录(IPV4)地址<br>那么AAAA记录将作为sockaddr_in6结构返回，而A记录则作为sockaddr_in结构返回<br>通常用的都是AF_INET</p>
<h4 id="端口-sin-port"><a href="#端口-sin-port" class="headerlink" title="端口 sin_port"></a>端口 sin_port</h4><p>存储端口号<br>要注意转换成网络字节顺序，用 htons<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">my_addr</span>;</span> </span><br><span class="line">my_addr.sin_port=htons(<span class="number">3333</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="地址-sin-addr"><a href="#地址-sin-addr" class="headerlink" title="地址 sin_addr"></a>地址 sin_addr</h4><p>存储IP地址，使用in_addr这个数据结构<br>阐述下in_addr的含义，很显然它是一个存储ip地址的共用体有三种表达方式<br>第一种用四个字节来表示IP地址的四个数字；<br>第二种用两个双字节来表示IP地址<br>第三种用一个长整型来表示IP地址<br>使用时需要用其成员 s_addr 传入一个整形地址<br>点分十进制字符串 –&gt; 无符号整形的变换用 inet_aton<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">my_addr</span>;</span> </span><br><span class="line">inet_aton(<span class="string">"127.0.0.1"</span>,&amp;my_addr.sin_addr);</span><br><span class="line"><span class="comment">// 字符串转整形，注意是直接转成网络字节序</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">my_addr</span>;</span> </span><br><span class="line">ser_addr.sin_addr.s_addr = htonl(INADDR_ANY); </span><br><span class="line"><span class="comment">// INADDR_ANY 直接是整形，但还需要注意字节序问题</span></span><br></pre></td></tr></table></figure>
<h4 id="空字节-sin-zero"><a href="#空字节-sin-zero" class="headerlink" title="空字节 sin_zero"></a>空字节 sin_zero</h4><p>是为了让sockaddr与sockaddr_in两个数据结构保持大小相同而保留的空字节<br>需要把 sin_zero 全部设为0值，使用 bzero 或 memset 函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">my_addr</span>;</span> </span><br><span class="line">bzero(&amp;my_addr,<span class="keyword">sizeof</span>(my_addr))</span><br></pre></td></tr></table></figure></p>
<h4 id="用法实例"><a href="#用法实例" class="headerlink" title="用法实例"></a>用法实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ser_addr</span>;</span> </span><br><span class="line"><span class="built_in">memset</span>(&amp;ser_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ser_addr));</span><br><span class="line"><span class="comment">// 初始化一段空间</span></span><br><span class="line">ser_addr.sin_family = AF_INET;</span><br><span class="line"><span class="comment">// 使用 TCPIPv4 协议簇</span></span><br><span class="line">ser_addr.sin_addr.s_addr = htonl(INADDR_ANY); </span><br><span class="line"><span class="comment">//IP地址，需要进行网络序转换，INADDR_ANY：本地地址</span></span><br><span class="line">ser_addr.sin_port = htons(SERVER_PORT);  </span><br><span class="line"><span class="comment">//端口号，需要网络序转换</span></span><br></pre></td></tr></table></figure>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h2><h4 id="字符串与整形的转换"><a href="#字符串与整形的转换" class="headerlink" title="字符串与整形的转换"></a>字符串与整形的转换</h4><ul>
<li><p>inet_aton</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp, struct in_addr *inp)</span></span>;</span><br><span class="line"><span class="comment">//将点分IP地址格式转换为网络字节序的无符号整型,</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>inet_ntoa</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">inet_ntoa</span> <span class="params">(struct in_addr in)</span></span>;</span><br><span class="line"><span class="comment">//将无符号整型转换为点分格式</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">inet_aton(“<span class="number">219.245</span><span class="number">.78</span><span class="number">.159</span>”,&amp;addr.sin_addr);</span><br><span class="line"><span class="comment">//无符号整型转换为点分字符串格式</span></span><br><span class="line"><span class="built_in">printf</span>(“%s”,inet_ntoa(addr.sin_addr));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="字节序转换"><a href="#字节序转换" class="headerlink" title="字节序转换"></a>字节序转换</h4><p>网络字节序<br>big endian<br>主机字节序<br>big endian &amp; little endian</p>
<p>主机为小端序需要转换<br>ntohs ntohl htons htonl</p>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="DNS-域名系统"><a href="#DNS-域名系统" class="headerlink" title="DNS 域名系统"></a>DNS 域名系统</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Domain Name System<br>一种用于TCP/IP应用程序的分布式数据库<br>提供主机名字和IP地址的转换及电子邮件选路信息<br><a href="http://www.xidian.edu.cn－202.117.112.35" target="_blank" rel="noopener">www.xidian.edu.cn－202.117.112.35</a><br>分布式指在Internet上的单个站点不能拥有所有的信息<br>每个站点保留自己的信息数据库<br>并运行一个服务程序供Internet上的其他系统（客户程序）使用；<br>对DNS的访问通过一个地址解析器完成</p>
<h4 id="主机名到IP地址"><a href="#主机名到IP地址" class="headerlink" title="主机名到IP地址"></a>主机名到IP地址</h4><p>gethostbyname：主机名到IP地址的转换<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function">struct hostent* <span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">struct hostent</span>&#123;</span><br><span class="line">    <span class="keyword">char</span>     *h_name;   <span class="comment">/*主机正式名称*/</span></span><br><span class="line">    <span class="keyword">char</span>    **h_aliases;    <span class="comment">/*别名列表，以NULL结束*/</span></span><br><span class="line">    <span class="keyword">int</span>     h_addrtype; <span class="comment">/*主机地址类型：AF_INET*/</span></span><br><span class="line">    <span class="keyword">int</span>     h_length;   <span class="comment">/*主机地址长度：4字节32位*/</span></span><br><span class="line">    <span class="keyword">char</span>    **h_addr_list;  <span class="comment">/*主机ip地址列表，以NULL结束*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="IP地址到主机名"><a href="#IP地址到主机名" class="headerlink" title="IP地址到主机名"></a>IP地址到主机名</h4><p>gethostbyaddr：IP地址到主机名的转换<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function">struct hostent *<span class="title">gethostbyaddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *addr,<span class="keyword">size_t</span> len,<span class="keyword">int</span> family)</span></span>;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">addr</span>;</span></span><br><span class="line"></span><br><span class="line">inet_aton(“<span class="number">202.117</span><span class="number">.112</span><span class="number">.10</span>”,&amp;addr);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">he</span>=<span class="title">gethostbyaddr</span>((<span class="title">char</span> *)<span class="title">addr</span>,4,<span class="title">AF_INET</span>);</span></span><br><span class="line"><span class="keyword">if</span>(he!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"h_name:%s\n"</span>,he-&gt;h_name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"gethostbyaddr error:%s\n"</span>,hstrerror(h_errno));</span><br></pre></td></tr></table></figure>
<p>解析器通常是应用程序的一部分，操作系统内核中的TCP/IP协议族对于DNS不知情；<br>应用程序请求TCP打开一个连接或使用UDP发送一个数据报之前，必须将主机名转换为IP地址；<br>相关RFC文档：rfc1034/1035等</p>
<p>DNS使用MX记录来实现邮件路由，它规定了域名的邮件服务器要么处理，要么向前转发有关该域名的邮件<br>CNAME记录：创建一个指定域名的别名（alias）<br>ftp.utopian.edu.cn 86400 IN CNAME master.utipian.edu.cn<br>相关命令：nslookup</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://1t4chi.com/2018/09/14/2018-09-15-Socket Address/" data-id="cjt6rg50200015uvqex0ocei2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2018-09-05-Socket_NetProgramming" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/05/2018-09-05-Socket_NetProgramming/" class="article-date">
  <time datetime="2018-09-05T00:35:46.097Z" itemprop="datePublished">2018-09-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Socket/">Socket</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/05/2018-09-05-Socket_NetProgramming/">Networt Programming</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Networt-Programming"><a href="#Networt-Programming" class="headerlink" title="Networt Programming"></a>Networt Programming</h1><h2 id="编程接口"><a href="#编程接口" class="headerlink" title="编程接口"></a>编程接口</h2><ul>
<li>Socket TCP/IP</li>
<li>AT&amp;T TLI OSI7</li>
</ul>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="网络程序设计模型"><a href="#网络程序设计模型" class="headerlink" title="网络程序设计模型"></a>网络程序设计模型</h2><h4 id="客户端-服务器模型-C-S"><a href="#客户端-服务器模型-C-S" class="headerlink" title="客户端/服务器模型 C/S"></a>客户端/服务器模型 C/S</h4><ul>
<li>非对称模型</li>
<li>重复型服务器</li>
<li>并发型服务器</li>
</ul>
<h4 id="浏览器-服务器模型-B-S"><a href="#浏览器-服务器模型-B-S" class="headerlink" title="浏览器/服务器模型 B/S"></a>浏览器/服务器模型 B/S</h4><ul>
<li>www 技术兴起，一种改进的 CS 结构，用于 web 应用</li>
<li>主要采用 http https 协议进行数据传输</li>
<li>三层结构<ul>
<li>客户端：即浏览器，负责客户和后台交互及其最终查询结果的输出</li>
<li>服务器：功能层，与后台数据库连接 将由数据库返回的结果返回客户端</li>
<li>数据库服务器：数据层，应客户请求进行各种查询和处理</li>
</ul>
</li>
</ul>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="客户端服务器通讯模式"><a href="#客户端服务器通讯模式" class="headerlink" title="客户端服务器通讯模式"></a>客户端服务器通讯模式</h2><h4 id="面向连接"><a href="#面向连接" class="headerlink" title="面向连接"></a>面向连接</h4><ul>
<li>connection-oriented</li>
<li>传输数据前建立稳定可靠数据通道</li>
<li>可靠稳定，但占用资源多</li>
<li>TCP</li>
</ul>
<h4 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h4><ul>
<li>connectionless</li>
<li>不用建立通道</li>
<li>不可靠，性能高</li>
<li>UDP</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://1t4chi.com/2018/09/05/2018-09-05-Socket_NetProgramming/" data-id="cjt6rg4zr00005uvqic8q8hat" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/OS/">OS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Socket/">Socket</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/12/05/Sock_semaphore/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/12/05/2018-10-20-Process Communication_Sharemem/">进程的通信——共享内存</a>
          </li>
        
          <li>
            <a href="/2018/12/05/2018-10-19-Process Communication_Msgqueue/">进程的通信——消息队列</a>
          </li>
        
          <li>
            <a href="/2018/12/05/2018-10-20-Process Communication_Pipe/">进程的通信——管道</a>
          </li>
        
          <li>
            <a href="/2018/12/04/2018-10-11-Socket IO/">Socket 的 IO 模型</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>